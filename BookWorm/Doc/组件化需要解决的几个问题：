

针对VC的组件的Push 和 present:
基类中需要提供启动组件需要的方法：以字典的形式提供。


针对VC组件的 pop 和 dismiss:

需要提供返回组件的回调~！


url形式：  yig://home?par1=xxx&par2=xxx

DYRouterConditon * condition = [DYRouterCondition defaultCondition];
condition.navigateType = PUSH;
condition.pars = @{};				//一个问题是如何实现model层解耦和页面传值之间的循环引用 和内存管理
condition.routerURL = NSURL..
condition.needLogin = YES;
condition.needCacheRouter;
[[DYRouter sharedInstance] routerWithCondition: condition callback:(^)(){
	//根据回调返回的字典处理得到的值。
}]



DYRouterCondition * condition = [DYRouterCondition defaultConditio	n];
condition.navigateType = POP;			//pop的话需要考虑navigation的层级问题,在退出的时候，向block赋值
[DYRouter sharedInstance] routerWithCondition: condition callback:nil;



跨组件之间的方法调用：
组件类型，是否需要初始化,组件是否是由单例提供，或者当前存在实例变量，需要用此实例变量，如果不能以初始化的形式提供，会稍微复杂。


组件和组件之间通信的方法：1、A组件直接跳转到B  2、A调用B的方法实现

组件化的概念：

完全独立的业务模块，登录注册模块，地图模块，网络模块，缓存模块

组件化：这些独立的业务模块组成一个app，但是模块和模块之间的耦合性降到最低


组件解耦需要解决的几个问题：
1：组件和组件之间的通信方式
2：启动组件需要的元数据该如何封装
3：内存管理


如果需要地图相关的内容，可以将地图模块 +（地图业务模块1|地图业务模块2|地图业务模块3） 作为一个组件，地图业务模块可以是一个只和地图模块耦合的页面  每个地图业务模块提供启动模块需要的内容。

